{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Next.js 15 Project with Turborepo",
        "description": "Initialize the project repository with Next.js 15 and Turborepo for monorepo management, including all required dependencies.",
        "details": "1. Create a new Turborepo monorepo structure\n2. Set up Next.js 15 application in the apps directory\n3. Configure TypeScript for type safety\n4. Install and configure core dependencies:\n   - React 19\n   - Tailwind CSS 4\n   - Shadcn UI components\n   - TanStack Query 5\n   - React Hook Form\n   - Zod\n   - Zustand\n   - Recharts\n5. Set up Vitest and React Testing Library\n6. Configure Storybook for component documentation\n7. Create basic folder structure for components, hooks, and utilities\n8. Set up ESLint and Prettier for code quality\n9. Configure CI/CD pipeline for automated testing",
        "testStrategy": "Verify that the project builds successfully and all dependencies are correctly installed. Run basic smoke tests to ensure the development environment works as expected. Test that Storybook launches correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Turborepo Monorepo Structure",
            "description": "Set up the base monorepo structure using Turborepo with proper configuration for workspace management.",
            "dependencies": [],
            "details": "1. Create a new directory for the project\n2. Initialize Git repository\n3. Create package.json with workspaces configuration\n4. Install Turborepo as a dev dependency\n5. Create turbo.json configuration file with pipeline setup\n6. Set up .gitignore file\n7. Create basic folder structure (apps, packages)\n\n```bash\n# Commands\nmkdir next15-turborepo && cd next15-turborepo\ngit init\nnpm init -y\nnpm install -D turbo\nmkdir -p apps packages\n```\n\n```json\n// package.json\n{\n  \"name\": \"next15-turborepo\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"workspaces\": [\n    \"apps/*\",\n    \"packages/*\"\n  ],\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"dev\": \"turbo run dev\",\n    \"lint\": \"turbo run lint\",\n    \"test\": \"turbo run test\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"^1.10.0\"\n  }\n}\n```\n\n```json\n// turbo.json\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/**\", \".next/**\", \"!.next/cache/**\"]\n    },\n    \"lint\": {},\n    \"dev\": {\n      \"cache\": false,\n      \"persistent\": true\n    },\n    \"test\": {\n      \"dependsOn\": [\"build\"]\n    }\n  }\n}\n```",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Next.js 15 Application",
            "description": "Set up a Next.js 15 application in the apps directory with TypeScript and essential configurations.",
            "dependencies": [
              1
            ],
            "details": "1. Create a new Next.js 15 application with TypeScript\n2. Configure Next.js app router\n3. Set up environment variables\n4. Configure TypeScript settings\n5. Create basic app structure\n\n```bash\n# Navigate to apps directory\ncd apps\n\n# Create Next.js app with TypeScript\nnpx create-next-app@latest web --typescript --tailwind --eslint --app --src-dir --import-alias \"@/*\"\n\n# Navigate back to root\ncd ..\n```\n\n```json\n// apps/web/next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  transpilePackages: [\"ui\"],\n  experimental: {\n    serverActions: true\n  }\n};\n\nmodule.exports = nextConfig;\n```\n\n```json\n// apps/web/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"plugins\": [{ \"name\": \"next\" }],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set Up Shared UI Package",
            "description": "Create a shared UI package in the packages directory for reusable components across applications.",
            "dependencies": [
              1
            ],
            "details": "1. Create a UI package in the packages directory\n2. Set up TypeScript configuration\n3. Configure package.json\n4. Create basic component structure\n5. Set up Tailwind CSS and Shadcn UI\n\n```bash\n# Create UI package directory\nmkdir -p packages/ui/src\ncd packages/ui\n\n# Initialize package\nnpm init -y\nnpm install -D typescript @types/react @types/node\nnpm install react react-dom\n\n# Create tsconfig.json\ntouch tsconfig.json\n\n# Navigate back to root\ncd ../..\n```\n\n```json\n// packages/ui/package.json\n{\n  \"name\": \"ui\",\n  \"version\": \"0.0.0\",\n  \"main\": \"./src/index.ts\",\n  \"types\": \"./src/index.ts\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"lint\": \"eslint .\",\n    \"build\": \"tsup src/index.ts --dts\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\",\n    \"eslint\": \"^8.0.0\",\n    \"react\": \"^19.0.0\",\n    \"tsup\": \"^7.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"peerDependencies\": {\n    \"react\": \"^19.0.0\"\n  }\n}\n```\n\n```json\n// packages/ui/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n```typescript\n// packages/ui/src/index.ts\nexport * from './components';\n```",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Install and Configure Dependencies",
            "description": "Install and configure all required dependencies including React 19, Tailwind CSS, state management, and form libraries.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Install core dependencies in the Next.js application\n2. Configure Tailwind CSS\n3. Set up Shadcn UI components\n4. Install and configure TanStack Query\n5. Set up React Hook Form with Zod\n6. Configure Zustand for state management\n7. Install Recharts for data visualization\n\n```bash\n# Navigate to Next.js app directory\ncd apps/web\n\n# Install dependencies\nnpm install @tanstack/react-query@5 react-hook-form zod @hookform/resolvers zustand recharts\nnpm install -D @tanstack/react-query-devtools@5\n\n# Install Shadcn UI\nnpx shadcn-ui@latest init\n\n# Navigate back to root\ncd ../..\n```\n\n```typescript\n// apps/web/src/lib/utils.ts\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n```typescript\n// apps/web/src/lib/store.ts\nimport { create } from 'zustand';\n\ninterface AppState {\n  // Define your state here\n  count: number;\n  increment: () => void;\n}\n\nexport const useAppStore = create<AppState>((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n}));\n```\n\n```typescript\n// apps/web/src/lib/query-client.ts\nimport { QueryClient } from '@tanstack/react-query';\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 60 * 1000,\n      refetchOnWindowFocus: false,\n    },\n  },\n});\n```",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Set Up Testing and Documentation",
            "description": "Configure testing frameworks (Vitest, React Testing Library) and Storybook for component documentation.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "1. Install Vitest and React Testing Library\n2. Configure test setup files\n3. Create basic test examples\n4. Install and configure Storybook\n5. Create initial stories for components\n\n```bash\n# Navigate to Next.js app directory\ncd apps/web\n\n# Install testing dependencies\nnpm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom\n\n# Install Storybook\nnpx storybook@latest init\n\n# Navigate back to root\ncd ../..\n```\n\n```typescript\n// apps/web/vitest.config.ts\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\nimport { resolve } from 'path';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n  },\n  resolve: {\n    alias: {\n      '@': resolve(__dirname, './src'),\n    },\n  },\n});\n```\n\n```typescript\n// apps/web/src/test/setup.ts\nimport '@testing-library/jest-dom';\n```\n\n```typescript\n// apps/web/src/components/button.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport { Button } from '@/components/ui/button';\n\ndescribe('Button', () => {\n  it('renders correctly', () => {\n    render(<Button>Click me</Button>);\n    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();\n  });\n});\n```\n\n```typescript\n// apps/web/src/stories/Button.stories.tsx\nimport type { Meta, StoryObj } from '@storybook/react';\nimport { Button } from '@/components/ui/button';\n\nconst meta: Meta<typeof Button> = {\n  title: 'UI/Button',\n  component: Button,\n  parameters: {\n    layout: 'centered',\n  },\n};\n\nexport default meta;\ntype Story = StoryObj<typeof Button>;\n\nexport const Primary: Story = {\n  args: {\n    children: 'Button',\n    variant: 'default',\n  },\n};\n```",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Create Equipment Data Models and Types",
        "description": "Define TypeScript interfaces and Zod schemas for equipment data models, including categories, statuses, and assignment information.",
        "details": "1. Create TypeScript interfaces for Equipment model:\n```typescript\ninterface Equipment {\n  id: string;\n  name: string;\n  categoryId: string;\n  status: 'Active' | 'In Repair' | 'Out of Service' | 'Retired';\n  assignedTo: string | null;\n  serialNumber: string;\n  lastCheckOut: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n2. Define Category model:\n```typescript\ninterface Category {\n  id: string;\n  name: string;\n  description?: string;\n}\n```\n\n3. Define Assignment History model:\n```typescript\ninterface AssignmentHistory {\n  id: string;\n  equipmentId: string;\n  userId: string;\n  checkOutDate: Date;\n  checkInDate: Date | null;\n  notes?: string;\n}\n```\n\n4. Create Zod schemas for validation:\n```typescript\nconst equipmentSchema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  categoryId: z.string().min(1, 'Category is required'),\n  status: z.enum(['Active', 'In Repair', 'Out of Service', 'Retired']),\n  assignedTo: z.string().nullable(),\n  serialNumber: z.string(),\n  lastCheckOut: z.date().nullable(),\n});\n```\n\n5. Create mock data for development and testing",
        "testStrategy": "Write unit tests to validate the Zod schemas with various input scenarios, including valid and invalid data. Test that TypeScript types are correctly implemented and provide proper type safety.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript Interfaces for Equipment Models",
            "description": "Define TypeScript interfaces for all equipment-related data models including Equipment, Category, and Assignment History.",
            "dependencies": [],
            "details": "1. Create a `types.ts` file in the models directory\n2. Define the Equipment interface with properties for id, name, categoryId, status (as a union type), assignedTo, serialNumber, lastCheckOut, createdAt, and updatedAt\n3. Define the Category interface with id, name, and optional description\n4. Define the AssignmentHistory interface with id, equipmentId, userId, checkOutDate, checkInDate, notes, and status\n5. Create additional interfaces for any related types like EquipmentStatus or AssignmentStatus\n6. Add proper JSDoc comments for each interface",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Zod Validation Schemas",
            "description": "Create Zod schemas for all equipment data models to enable runtime validation and type inference.",
            "dependencies": [
              1
            ],
            "details": "1. Create a `schemas.ts` file in the models directory\n2. Implement the equipmentSchema with appropriate Zod validators:\n   - Use z.string().uuid() for IDs\n   - Use z.enum() for status values\n   - Use z.string().nullable() for optional assignedTo\n   - Use z.date() for date fields\n3. Implement categorySchema with validators for all fields\n4. Implement assignmentHistorySchema with appropriate validators\n5. Export type definitions derived from schemas using z.infer<typeof schemaName>\n6. Add custom error messages for validation failures",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Generate Mock Data Factory Functions",
            "description": "Create factory functions to generate realistic mock data for testing and development purposes.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create a `mocks.ts` file in the models directory\n2. Implement a createMockEquipment() function that generates random but realistic equipment data\n3. Implement createMockCategory() for generating category data\n4. Implement createMockAssignmentHistory() for generating assignment history entries\n5. Create a generateMockDatabase() function that creates a complete set of related mock data\n6. Use libraries like faker.js to generate realistic names, descriptions, and serial numbers\n7. Ensure generated data passes Zod schema validation\n8. Add options to control the generation (e.g., number of items, specific status values)",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Equipment Listing View",
        "description": "Create a responsive table/card-based layout for displaying equipment with filtering, search, and action capabilities.",
        "details": "1. Create a new page for equipment listing\n2. Implement a data table component using Shadcn UI components\n3. Define columns for Equipment Name & Category, Status, Assigned To, Serial Number, Last Check Out\n4. Add status indicators with appropriate colors (Active: green, In Repair: yellow, Out of Service: red, Retired: gray)\n5. Implement user avatars or initials for the 'Assigned To' column\n6. Add action buttons for each row (View, Edit, Archive)\n7. Implement responsive design for mobile view (cards instead of table)\n8. Add pagination for large datasets\n9. Implement data fetching using TanStack Query\n\n```tsx\n// Example component structure\nconst EquipmentList = () => {\n  const { data, isLoading } = useQuery({\n    queryKey: ['equipment'],\n    queryFn: fetchEquipment\n  });\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">Equipment List</h1>\n      \n      {/* Filters and search will be added in task #4 */}\n      \n      {isLoading ? (\n        <LoadingSpinner />\n      ) : (\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>Equipment Name & Category</TableHead>\n              <TableHead>Status</TableHead>\n              <TableHead>Assigned To</TableHead>\n              <TableHead>Serial Number</TableHead>\n              <TableHead>Last Check Out</TableHead>\n              <TableHead>Actions</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {data.map((item) => (\n              <TableRow key={item.id}>\n                <TableCell>{item.name} ({item.category})</TableCell>\n                <TableCell>\n                  <StatusBadge status={item.status} />\n                </TableCell>\n                <TableCell>\n                  <UserAvatar user={item.assignedTo} />\n                </TableCell>\n                <TableCell>{item.serialNumber}</TableCell>\n                <TableCell>{formatDate(item.lastCheckOut)}</TableCell>\n                <TableCell>\n                  <ActionButtons item={item} />\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "Create component tests using Vitest and React Testing Library to verify the table renders correctly with mock data. Test responsive behavior by simulating different viewport sizes. Create Storybook stories to document the component's various states (loading, empty, with data).",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Equipment Table Component",
            "description": "Implement the core table component for displaying equipment data with all required columns and styling",
            "dependencies": [],
            "details": "1. Create a new EquipmentTable component using Shadcn UI Table components\n2. Define columns for Equipment Name & Category, Status, Assigned To, Serial Number, Last Check Out\n3. Implement StatusBadge component for visual status indicators with appropriate colors\n4. Add user avatars or initials for the 'Assigned To' column\n5. Implement action buttons (View, Edit, Archive) with dropdown menu\n6. Add proper TypeScript interfaces for equipment data\n7. Implement basic table styling with hover effects and proper spacing",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Data Fetching and State Management",
            "description": "Set up data fetching logic using TanStack Query and implement UI state management for the equipment listing",
            "dependencies": [
              1
            ],
            "details": "1. Create a custom hook useEquipmentData to fetch equipment data\n2. Implement loading, error, and empty states for the table\n3. Set up TanStack Query for data fetching with proper caching\n4. Create state management for sorting, pagination, and filtering\n5. Implement optimistic updates for status changes\n6. Add debounced search functionality\n7. Set up proper error handling with user-friendly error messages",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Responsive Design",
            "description": "Ensure the equipment listing view works well across different device sizes with appropriate layout changes",
            "dependencies": [
              1
            ],
            "details": "1. Create a responsive layout that switches between table and card views based on screen size\n2. Implement a card component for mobile view that displays essential equipment information\n3. Use CSS Grid or Flexbox for responsive layouts\n4. Hide less important columns on smaller screens\n5. Ensure action buttons are accessible on all device sizes\n6. Test and optimize for various breakpoints (mobile, tablet, desktop)\n7. Implement touch-friendly interactions for mobile users",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Selection and Bulk Actions",
            "description": "Add functionality to select multiple equipment items and perform bulk actions",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Add checkbox selection to table rows\n2. Implement select all functionality with indeterminate state\n3. Create a bulk actions toolbar that appears when items are selected\n4. Implement bulk archive functionality with confirmation dialog\n5. Add bulk reassign capability with user selection dropdown\n6. Ensure proper state management for selected items\n7. Add visual feedback for selected rows\n8. Implement keyboard accessibility for selection",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Filtering and Search Functionality",
        "description": "Add filtering capabilities for Category, Status, and Assigned To, along with a search bar for quick equipment lookup.",
        "details": "1. Create filter components for Category, Status, and Assigned To\n2. Implement a search bar component with debounce functionality\n3. Use Zustand to manage filter and search state\n4. Integrate filters with the equipment listing view\n5. Update TanStack Query to handle filtered and searched data\n\n```tsx\n// Filter store with Zustand\ninterface FilterState {\n  search: string;\n  categoryId: string | null;\n  status: string | null;\n  assignedTo: string | null;\n  setSearch: (search: string) => void;\n  setCategoryId: (categoryId: string | null) => void;\n  setStatus: (status: string | null) => void;\n  setAssignedTo: (assignedTo: string | null) => void;\n  resetFilters: () => void;\n}\n\nconst useFilterStore = create<FilterState>((set) => ({\n  search: '',\n  categoryId: null,\n  status: null,\n  assignedTo: null,\n  setSearch: (search) => set({ search }),\n  setCategoryId: (categoryId) => set({ categoryId }),\n  setStatus: (status) => set({ status }),\n  setAssignedTo: (assignedTo) => set({ assignedTo }),\n  resetFilters: () => set({ search: '', categoryId: null, status: null, assignedTo: null }),\n}));\n\n// Filter component\nconst EquipmentFilters = () => {\n  const { search, categoryId, status, assignedTo, setSearch, setCategoryId, setStatus, setAssignedTo, resetFilters } = useFilterStore();\n  \n  return (\n    <div className=\"flex flex-col md:flex-row gap-4 mb-6\">\n      <Input\n        placeholder=\"Search equipment...\"\n        value={search}\n        onChange={(e) => setSearch(e.target.value)}\n        className=\"max-w-xs\"\n      />\n      \n      <Select value={categoryId || ''} onValueChange={(value) => setCategoryId(value || null)}>\n        <SelectTrigger className=\"w-[180px]\">\n          <SelectValue placeholder=\"Category\" />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"\">All Categories</SelectItem>\n          {/* Map through categories */}\n        </SelectContent>\n      </Select>\n      \n      {/* Similar selects for Status and Assigned To */}\n      \n      <Button variant=\"outline\" onClick={resetFilters}>Reset Filters</Button>\n    </div>\n  );\n};\n```",
        "testStrategy": "Test the filter components in isolation using Vitest and React Testing Library. Verify that the Zustand store correctly updates state when filters are applied. Test the integration with the equipment listing to ensure filtered results are displayed correctly. Create Storybook stories for the filter components.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Filter Components and State Management",
            "description": "Create filter components for Category, Status, and Assigned To, and set up Zustand store for state management",
            "dependencies": [],
            "details": "1. Create a Zustand store for filter state with properties for search, categoryId, status, assignedTo, and their setter functions\n2. Implement a CategoryFilter component using a select dropdown that fetches categories from the API\n3. Implement a StatusFilter component with predefined status options (Active, In Repair, Out of Service, Retired)\n4. Create an AssignedToFilter component that fetches users from the API\n5. Add reset functionality to clear all filters\n6. Write unit tests for each filter component and the Zustand store",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Search Bar with Debounce",
            "description": "Create a search component with debounce functionality to prevent excessive API calls",
            "dependencies": [
              1
            ],
            "details": "1. Create a SearchBar component with an input field and search icon\n2. Implement debounce functionality using a custom hook or a library like use-debounce\n3. Connect the search component to the Zustand filter store\n4. Add clear search button functionality\n5. Style the search component according to the design system\n6. Write tests to verify debounce behavior and state updates\n7. Create Storybook stories for the search component in different states",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Filters with Data Fetching Layer",
            "description": "Connect the filter and search state to the TanStack Query data fetching to display filtered results",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Modify the equipment fetching query to accept filter parameters\n2. Update the queryKey to include filter state to trigger refetches when filters change\n3. Implement URL query parameter synchronization with filter state\n4. Add loading states for when filters are applied\n5. Create empty state UI for when no results match the filters\n6. Implement filter count indicators to show how many filters are active\n7. Write integration tests to verify filtered data is correctly displayed\n8. Add performance optimizations to prevent unnecessary refetches",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Add/Edit Equipment Form",
        "description": "Create a form for adding new equipment or editing existing equipment details with validation using React Hook Form and Zod.",
        "details": "1. Create a modal or dedicated page for the equipment form\n2. Implement form fields for Name, Category, Status, Assigned To, Serial Number\n3. Use React Hook Form with Zod validation\n4. Add form submission handling with TanStack Query mutations\n5. Implement success/error notifications\n\n```tsx\nconst EquipmentForm = ({ equipment, onSuccess }) => {\n  const { categories } = useCategories();\n  const { users } = useUsers();\n  \n  const form = useForm<z.infer<typeof equipmentSchema>>({  \n    resolver: zodResolver(equipmentSchema),\n    defaultValues: equipment || {\n      name: '',\n      categoryId: '',\n      status: 'Active',\n      assignedTo: null,\n      serialNumber: '',\n      lastCheckOut: null,\n    }\n  });\n  \n  const mutation = useMutation({\n    mutationFn: equipment ? updateEquipment : createEquipment,\n    onSuccess: () => {\n      toast.success(`Equipment ${equipment ? 'updated' : 'created'} successfully`);\n      onSuccess();\n    },\n    onError: (error) => {\n      toast.error(`Failed to ${equipment ? 'update' : 'create'} equipment: ${error.message}`);\n    }\n  });\n  \n  const onSubmit = (data) => {\n    mutation.mutate(equipment ? { id: equipment.id, ...data } : data);\n  };\n  \n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n        <FormField\n          control={form.control}\n          name=\"name\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Equipment Name</FormLabel>\n              <FormControl>\n                <Input {...field} />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        \n        {/* Similar FormField components for other fields */}\n        \n        <Button type=\"submit\" disabled={mutation.isPending}>\n          {mutation.isPending ? 'Saving...' : equipment ? 'Update Equipment' : 'Add Equipment'}\n        </Button>\n      </form>\n    </Form>\n  );\n};\n```",
        "testStrategy": "Test form validation with various input scenarios. Verify that form submission correctly calls the appropriate mutation function. Test error handling and success notifications. Create Storybook stories for the form in different states (create mode, edit mode, with validation errors).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design form structure and fields",
            "description": "Create the form layout with all required fields for equipment management",
            "dependencies": [],
            "details": "1. Design form layout with fields for Name, Category, Status, Assigned To, and Serial Number\n2. Set up React Hook Form with initial configuration\n3. Create form component structure with proper labeling and accessibility\n4. Implement responsive design for the form to work on different screen sizes\n5. Add conditional rendering for create vs. edit mode",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement validation logic with Zod",
            "description": "Set up form validation rules using Zod schema validation",
            "dependencies": [
              1
            ],
            "details": "1. Define Zod schema for equipment form validation\n2. Set up validation rules for required fields\n3. Implement custom validation for serial numbers\n4. Configure error message display for validation failures\n5. Connect Zod resolver to React Hook Form\n6. Test validation with various input scenarios",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create form submission handling",
            "description": "Implement form submission logic with TanStack Query mutations",
            "dependencies": [
              2
            ],
            "details": "1. Set up TanStack Query mutation hooks for create and update operations\n2. Implement form submission handler function\n3. Add loading states during submission\n4. Create logic to handle different submission paths (create vs. edit)\n5. Implement onSuccess callback handling\n6. Set up proper data transformation between form and API",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement error handling and notifications",
            "description": "Add comprehensive error management and success notifications",
            "dependencies": [
              3
            ],
            "details": "1. Implement error catching for form submission failures\n2. Create error display components for API errors\n3. Set up success notification system\n4. Add form reset functionality after successful submission\n5. Implement confirmation dialogs for potentially destructive actions\n6. Create retry mechanisms for failed submissions",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Equipment Categories Management",
        "description": "Create functionality to manage equipment categories, including adding, editing, and deleting categories, and assigning equipment to categories.",
        "details": "1. Create a Categories page or modal\n2. Implement a table to display existing categories\n3. Add form for creating/editing categories\n4. Implement delete functionality with confirmation\n5. Create API integration for category management\n\n```tsx\nconst CategoriesManagement = () => {\n  const { data: categories, isLoading } = useQuery({\n    queryKey: ['categories'],\n    queryFn: fetchCategories\n  });\n  \n  const [selectedCategory, setSelectedCategory] = useState(null);\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  \n  const deleteMutation = useMutation({\n    mutationFn: deleteCategory,\n    onSuccess: () => {\n      toast.success('Category deleted successfully');\n      queryClient.invalidateQueries({ queryKey: ['categories'] });\n    }\n  });\n  \n  const handleDelete = (category) => {\n    if (confirm(`Are you sure you want to delete ${category.name}?`)) {\n      deleteMutation.mutate(category.id);\n    }\n  };\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <div className=\"flex justify-between items-center mb-6\">\n        <h1 className=\"text-2xl font-bold\">Equipment Categories</h1>\n        <Button onClick={() => { setSelectedCategory(null); setIsFormOpen(true); }}>\n          Add Category\n        </Button>\n      </div>\n      \n      {isLoading ? (\n        <LoadingSpinner />\n      ) : (\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>Name</TableHead>\n              <TableHead>Description</TableHead>\n              <TableHead>Actions</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {categories.map((category) => (\n              <TableRow key={category.id}>\n                <TableCell>{category.name}</TableCell>\n                <TableCell>{category.description}</TableCell>\n                <TableCell>\n                  <Button variant=\"ghost\" onClick={() => { setSelectedCategory(category); setIsFormOpen(true); }}>\n                    Edit\n                  </Button>\n                  <Button variant=\"destructive\" onClick={() => handleDelete(category)}>\n                    Delete\n                  </Button>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      )}\n      \n      {isFormOpen && (\n        <CategoryForm \n          category={selectedCategory} \n          onClose={() => setIsFormOpen(false)} \n          onSuccess={() => {\n            setIsFormOpen(false);\n            queryClient.invalidateQueries({ queryKey: ['categories'] });\n          }} \n        />\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "Test the categories table rendering and CRUD operations. Verify that the form correctly handles create and update operations. Test delete confirmation and error handling. Create Storybook stories for the categories management components.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Categories Table Component",
            "description": "Create a responsive table component to display and manage equipment categories with sorting and pagination capabilities.",
            "dependencies": [],
            "details": "1. Create a new CategoryTable component using Shadcn UI table components\n2. Define columns for Category Name, Description, Equipment Count, and Actions\n3. Implement row rendering with appropriate data formatting\n4. Add action buttons for Edit and Delete operations\n5. Implement sorting functionality by category name\n6. Add pagination for large category lists\n7. Create loading and empty states for the table\n8. Implement responsive design for mobile view",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Category Form and CRUD Operations",
            "description": "Create a form component for adding and editing categories with validation, and implement the API integration for CRUD operations.",
            "dependencies": [
              1
            ],
            "details": "1. Create a CategoryForm component using React Hook Form with Zod validation\n2. Implement form fields for Name, Description, and other relevant fields\n3. Create useMutation hooks for create, update, and delete operations\n4. Implement form submission handling with proper error management\n5. Add optimistic updates to the UI when operations succeed\n6. Implement form reset functionality\n7. Create success/error notifications for CRUD operations\n8. Add form validation with appropriate error messages",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Confirmation Dialogs and State Management",
            "description": "Create confirmation dialogs for destructive actions and implement global state management for the categories functionality.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create a DeleteConfirmationDialog component for category deletion\n2. Implement a state management approach using React Context or Zustand\n3. Create a CategoriesProvider to manage categories state globally\n4. Implement category selection functionality\n5. Add modal state management for form and confirmation dialogs\n6. Create a categories hook (useCategories) to access category data throughout the application\n7. Implement error boundary for the categories management section\n8. Add analytics tracking for category management actions",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Equipment Status Management",
        "description": "Create functionality to track and update equipment status (Active, In Repair, Out of Service, Retired) with visual status indicators.",
        "details": "1. Create a StatusBadge component for visual status indicators\n2. Implement status update functionality in the equipment edit form\n3. Add quick status change actions in the equipment list\n4. Create a status history tracking system\n\n```tsx\n// StatusBadge component\nconst StatusBadge = ({ status }) => {\n  const statusConfig = {\n    'Active': { color: 'bg-green-100 text-green-800', icon: CheckCircleIcon },\n    'In Repair': { color: 'bg-yellow-100 text-yellow-800', icon: WrenchIcon },\n    'Out of Service': { color: 'bg-red-100 text-red-800', icon: XCircleIcon },\n    'Retired': { color: 'bg-gray-100 text-gray-800', icon: ArchiveIcon },\n  };\n  \n  const config = statusConfig[status] || statusConfig['Active'];\n  \n  return (\n    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}>\n      <config.icon className=\"-ml-0.5 mr-1.5 h-3 w-3\" />\n      {status}\n    </span>\n  );\n};\n\n// Quick status update component\nconst StatusUpdateMenu = ({ equipment }) => {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: updateEquipmentStatus,\n    onSuccess: () => {\n      toast.success('Status updated successfully');\n      queryClient.invalidateQueries({ queryKey: ['equipment'] });\n    }\n  });\n  \n  const handleStatusChange = (status) => {\n    mutation.mutate({ id: equipment.id, status });\n  };\n  \n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"ghost\" size=\"sm\">\n          <StatusBadge status={equipment.status} />\n          <ChevronDownIcon className=\"ml-1 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent>\n        <DropdownMenuLabel>Change Status</DropdownMenuLabel>\n        <DropdownMenuSeparator />\n        <DropdownMenuItem onClick={() => handleStatusChange('Active')}>\n          <CheckCircleIcon className=\"mr-2 h-4 w-4 text-green-500\" />\n          Active\n        </DropdownMenuItem>\n        <DropdownMenuItem onClick={() => handleStatusChange('In Repair')}>\n          <WrenchIcon className=\"mr-2 h-4 w-4 text-yellow-500\" />\n          In Repair\n        </DropdownMenuItem>\n        <DropdownMenuItem onClick={() => handleStatusChange('Out of Service')}>\n          <XCircleIcon className=\"mr-2 h-4 w-4 text-red-500\" />\n          Out of Service\n        </DropdownMenuItem>\n        <DropdownMenuItem onClick={() => handleStatusChange('Retired')}>\n          <ArchiveIcon className=\"mr-2 h-4 w-4 text-gray-500\" />\n          Retired\n        </DropdownMenuItem>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n};\n```",
        "testStrategy": "Test the StatusBadge component to ensure it correctly displays different statuses with appropriate colors and icons. Test the status update functionality to verify it correctly updates equipment status. Create Storybook stories for the status components in different states.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create StatusBadge Component",
            "description": "Implement a reusable StatusBadge component that visually represents equipment status with appropriate colors and icons",
            "dependencies": [],
            "details": "Create a StatusBadge.tsx component that accepts a status prop and renders the appropriate styling based on status type (Active, In Repair, Out of Service, Retired). Implement the component with conditional styling using Tailwind CSS classes. Include appropriate icons from your icon library for each status type. Add hover effects to improve user experience. Create Storybook stories to showcase all possible status states.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Status Update Functionality",
            "description": "Add the ability to change equipment status through the edit form and update the database",
            "dependencies": [
              1
            ],
            "details": "Enhance the equipment edit form to include a status dropdown selector. Implement form validation for status changes. Create a mutation function using TanStack Query to update the status in the database. Add optimistic updates to immediately reflect status changes in the UI. Implement error handling for failed status updates. Update the form submission handler to include the new status field.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Status History Tracking System",
            "description": "Implement functionality to record and display a history of status changes for each equipment item",
            "dependencies": [
              1,
              2
            ],
            "details": "Design and implement a data structure to store status change history (timestamp, previous status, new status, user). Create an API endpoint to record status changes when they occur. Implement a StatusHistory component to display the timeline of status changes. Add this component to the equipment detail view. Ensure status changes are recorded during both form submissions and quick actions. Include user information with each status change record.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Assignment and Check-in/out History",
        "description": "Create functionality to assign equipment to users/technicians and track check-in/check-out history with timestamps.",
        "details": "1. Create an assignment form/modal\n2. Implement check-in and check-out functionality\n3. Create a history view for each equipment item\n4. Update the equipment list to show the last check-out date\n5. Implement user selection dropdown\n\n```tsx\n// Assignment modal\nconst AssignmentModal = ({ equipment, isOpen, onClose }) => {\n  const { users } = useUsers();\n  const queryClient = useQueryClient();\n  \n  const form = useForm({\n    resolver: zodResolver(assignmentSchema),\n    defaultValues: {\n      userId: '',\n      notes: '',\n    }\n  });\n  \n  const mutation = useMutation({\n    mutationFn: assignEquipment,\n    onSuccess: () => {\n      toast.success('Equipment assigned successfully');\n      queryClient.invalidateQueries({ queryKey: ['equipment'] });\n      onClose();\n    }\n  });\n  \n  const onSubmit = (data) => {\n    mutation.mutate({\n      equipmentId: equipment.id,\n      userId: data.userId,\n      notes: data.notes,\n      checkOutDate: new Date(),\n    });\n  };\n  \n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent>\n        <DialogHeader>\n          <DialogTitle>Assign Equipment</DialogTitle>\n          <DialogDescription>\n            Assign {equipment?.name} to a user and record check-out details.\n          </DialogDescription>\n        </DialogHeader>\n        \n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n            <FormField\n              control={form.control}\n              name=\"userId\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Assign To</FormLabel>\n                  <Select onValueChange={field.onChange} defaultValue={field.value}>\n                    <FormControl>\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select a user\" />\n                      </SelectTrigger>\n                    </FormControl>\n                    <SelectContent>\n                      {users.map((user) => (\n                        <SelectItem key={user.id} value={user.id}>\n                          {user.name}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            \n            <FormField\n              control={form.control}\n              name=\"notes\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Notes</FormLabel>\n                  <FormControl>\n                    <Textarea {...field} />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            \n            <DialogFooter>\n              <Button type=\"button\" variant=\"outline\" onClick={onClose}>Cancel</Button>\n              <Button type=\"submit\" disabled={mutation.isPending}>\n                {mutation.isPending ? 'Assigning...' : 'Assign & Check Out'}\n              </Button>\n            </DialogFooter>\n          </form>\n        </Form>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\n// History view component\nconst EquipmentHistory = ({ equipmentId }) => {\n  const { data: history, isLoading } = useQuery({\n    queryKey: ['equipment-history', equipmentId],\n    queryFn: () => fetchEquipmentHistory(equipmentId)\n  });\n  \n  return (\n    <div className=\"space-y-4\">\n      <h3 className=\"text-lg font-medium\">Assignment History</h3>\n      \n      {isLoading ? (\n        <LoadingSpinner />\n      ) : history.length === 0 ? (\n        <p className=\"text-muted-foreground\">No history records found.</p>\n      ) : (\n        <div className=\"border rounded-md\">\n          {history.map((record) => (\n            <div key={record.id} className=\"p-4 border-b last:border-b-0\">\n              <div className=\"flex justify-between\">\n                <div>\n                  <span className=\"font-medium\">{record.userName}</span>\n                  <span className=\"text-muted-foreground ml-2\">\n                    {formatDate(record.checkOutDate)}\n                  </span>\n                </div>\n                <div>\n                  {record.checkInDate ? (\n                    <span className=\"text-green-600\">Returned {formatDate(record.checkInDate)}</span>\n                  ) : (\n                    <span className=\"text-yellow-600\">Currently checked out</span>\n                  )}\n                </div>\n              </div>\n              {record.notes && <p className=\"mt-2 text-sm\">{record.notes}</p>}\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "Test the assignment form validation and submission. Verify that check-in and check-out operations correctly update the equipment status and history. Test the history view component to ensure it displays the correct information. Create Storybook stories for the assignment and history components.",
        "priority": "high",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Assignment Form and Modal",
            "description": "Implement a form modal for assigning equipment to users with proper validation and submission handling",
            "dependencies": [],
            "details": "Create a React component for the assignment modal with form fields for user selection, purpose, and expected return date. Implement form validation using React Hook Form and Zod. Add submission handling with TanStack Query mutations. Include error handling and success notifications. Style the modal using the design system components.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Check-in/Check-out Operations",
            "description": "Build the core functionality for checking equipment in and out with proper status updates and validation",
            "dependencies": [
              1
            ],
            "details": "Create API service functions for check-in and check-out operations. Implement business logic for validating check-out conditions (e.g., equipment must be available). Add timestamp recording for all operations. Update equipment status when checked out or in. Implement optimistic updates in the UI for better user experience.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop History View Component",
            "description": "Create a component to display the complete history of equipment assignments and status changes",
            "dependencies": [
              2
            ],
            "details": "Build a timeline component to visualize equipment history. Implement filtering options for history entries by type (assignment, check-in, check-out, status change). Add pagination for equipment with extensive history. Create a detailed view for each history entry showing user, timestamps, and notes. Style the history view according to the design system.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate with Equipment List and Detail Views",
            "description": "Connect the assignment and history functionality with the existing equipment components",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Update the equipment list to show current assignment status and last check-out date. Add action buttons for check-in/check-out in the equipment detail view. Implement a history tab in the equipment detail page. Create a data refresh strategy to ensure equipment status is always current. Add permissions checking to control who can perform assignment operations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Bulk Actions",
        "description": "Add functionality to select multiple equipment items for bulk actions such as archiving or reassigning.",
        "details": "1. Implement row selection in the equipment table\n2. Create a bulk actions toolbar that appears when items are selected\n3. Implement bulk archive functionality\n4. Implement bulk reassign functionality\n5. Add confirmation dialogs for bulk actions\n\n```tsx\n// Enhanced equipment list with selection\nconst EquipmentList = () => {\n  const [selectedItems, setSelectedItems] = useState([]);\n  const { data, isLoading } = useQuery({\n    queryKey: ['equipment'],\n    queryFn: fetchEquipment\n  });\n  \n  const handleSelectAll = (e) => {\n    if (e.target.checked) {\n      setSelectedItems(data.map(item => item.id));\n    } else {\n      setSelectedItems([]);\n    }\n  };\n  \n  const handleSelectItem = (id) => {\n    setSelectedItems(prev => {\n      if (prev.includes(id)) {\n        return prev.filter(itemId => itemId !== id);\n      } else {\n        return [...prev, id];\n      }\n    });\n  };\n  \n  const [bulkActionOpen, setBulkActionOpen] = useState(false);\n  const [bulkAction, setBulkAction] = useState(null);\n  \n  const handleBulkAction = (action) => {\n    setBulkAction(action);\n    setBulkActionOpen(true);\n  };\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">Equipment List</h1>\n      \n      {selectedItems.length > 0 && (\n        <div className=\"bg-muted p-4 rounded-md mb-4 flex items-center justify-between\">\n          <span>{selectedItems.length} items selected</span>\n          <div className=\"space-x-2\">\n            <Button variant=\"outline\" onClick={() => handleBulkAction('archive')}>\n              Archive Selected\n            </Button>\n            <Button variant=\"outline\" onClick={() => handleBulkAction('reassign')}>\n              Reassign Selected\n            </Button>\n            <Button variant=\"ghost\" onClick={() => setSelectedItems([])}>\n              Clear Selection\n            </Button>\n          </div>\n        </div>\n      )}\n      \n      {/* Table with checkboxes */}\n      <Table>\n        <TableHeader>\n          <TableRow>\n            <TableHead className=\"w-12\">\n              <Checkbox \n                checked={selectedItems.length === data?.length} \n                onCheckedChange={handleSelectAll} \n              />\n            </TableHead>\n            <TableHead>Equipment Name & Category</TableHead>\n            {/* Other headers */}\n          </TableRow>\n        </TableHeader>\n        <TableBody>\n          {data?.map((item) => (\n            <TableRow key={item.id}>\n              <TableCell>\n                <Checkbox \n                  checked={selectedItems.includes(item.id)} \n                  onCheckedChange={() => handleSelectItem(item.id)} \n                />\n              </TableCell>\n              <TableCell>{item.name} ({item.category})</TableCell>\n              {/* Other cells */}\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n      \n      {/* Bulk action modals */}\n      {bulkActionOpen && bulkAction === 'archive' && (\n        <BulkArchiveModal \n          selectedItems={selectedItems} \n          isOpen={bulkActionOpen} \n          onClose={() => setBulkActionOpen(false)} \n          onSuccess={() => {\n            setSelectedItems([]);\n            setBulkActionOpen(false);\n          }} \n        />\n      )}\n      \n      {bulkActionOpen && bulkAction === 'reassign' && (\n        <BulkReassignModal \n          selectedItems={selectedItems} \n          isOpen={bulkActionOpen} \n          onClose={() => setBulkActionOpen(false)} \n          onSuccess={() => {\n            setSelectedItems([]);\n            setBulkActionOpen(false);\n          }} \n        />\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "Test the selection functionality to ensure items can be selected and deselected correctly. Test bulk action modals to verify they correctly process the selected items. Test confirmation dialogs and error handling. Create Storybook stories for the bulk action components.",
        "priority": "low",
        "dependencies": [
          3,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Row Selection in Equipment Table",
            "description": "Add functionality to select multiple rows in the equipment table with checkboxes and selection state management.",
            "dependencies": [],
            "details": "Create a selection mechanism with checkboxes in the equipment table. Implement state management for tracking selected items using useState or context. Add a 'select all' checkbox in the table header. Update the table row styling to indicate selected state. Ensure selection state persists during pagination and filtering.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Bulk Actions Toolbar and Confirmation Dialogs",
            "description": "Implement a contextual toolbar that appears when items are selected and create confirmation dialogs for bulk actions.",
            "dependencies": [
              1
            ],
            "details": "Develop a toolbar component that appears when one or more items are selected. Include action buttons for archive, reassign, and other bulk operations. Create reusable confirmation dialog components with dynamic content based on action type and selection count. Implement proper focus management for accessibility. Add error handling and success notifications for bulk operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Bulk Action Execution Logic",
            "description": "Create the backend integration and state management for executing bulk actions on selected equipment items.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement API integration for bulk operations using TanStack Query mutations. Create handlers for different bulk actions (archive, reassign, etc.). Develop error handling for partial successes in bulk operations. Implement optimistic updates for immediate UI feedback. Add loading states during bulk operations execution. Update cache and refetch data after successful bulk operations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Responsive Design and Accessibility",
        "description": "Ensure the application is fully responsive across desktop and mobile devices, and meets accessibility standards.",
        "details": "1. Implement responsive layouts for all pages and components\n2. Add mobile-specific views for the equipment list (card view)\n3. Ensure proper keyboard navigation\n4. Add ARIA attributes for screen readers\n5. Implement focus management for modals and dialogs\n6. Test and fix any accessibility issues\n7. Ensure color contrast meets WCAG standards\n8. Add skip links for keyboard users\n\n```tsx\n// Example of responsive equipment list with card view for mobile\nconst EquipmentList = () => {\n  const { data, isLoading } = useQuery({\n    queryKey: ['equipment'],\n    queryFn: fetchEquipment\n  });\n  \n  // Use a media query hook to detect viewport size\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\" id=\"main-content\">Equipment List</h1>\n      \n      {/* Skip link for keyboard users */}\n      <a href=\"#main-content\" className=\"sr-only focus:not-sr-only focus:absolute focus:p-2 focus:bg-white\">\n        Skip to main content\n      </a>\n      \n      {isLoading ? (\n        <LoadingSpinner aria-label=\"Loading equipment data\" />\n      ) : isMobile ? (\n        // Card view for mobile\n        <div className=\"grid grid-cols-1 gap-4\">\n          {data.map((item) => (\n            <div key={item.id} className=\"border rounded-lg p-4 shadow-sm\">\n              <div className=\"flex justify-between items-start\">\n                <h3 className=\"font-medium\">{item.name}</h3>\n                <StatusBadge status={item.status} />\n              </div>\n              <p className=\"text-sm text-muted-foreground mt-1\">{item.category}</p>\n              \n              <div className=\"mt-3 grid grid-cols-2 gap-2 text-sm\">\n                <div>\n                  <span className=\"block text-muted-foreground\">Assigned To</span>\n                  <UserAvatar user={item.assignedTo} showName />\n                </div>\n                <div>\n                  <span className=\"block text-muted-foreground\">Serial Number</span>\n                  {item.serialNumber}\n                </div>\n              </div>\n              \n              <div className=\"mt-4 flex justify-end space-x-2\">\n                <Button size=\"sm\" variant=\"outline\" asChild>\n                  <Link to={`/equipment/${item.id}`} aria-label={`View details for ${item.name}`}>\n                    View\n                  </Link>\n                </Button>\n                <Button size=\"sm\" variant=\"outline\" asChild>\n                  <Link to={`/equipment/${item.id}/edit`} aria-label={`Edit ${item.name}`}>\n                    Edit\n                  </Link>\n                </Button>\n              </div>\n            </div>\n          ))}\n        </div>\n      ) : (\n        // Table view for desktop\n        <Table aria-label=\"Equipment list\">\n          <TableHeader>\n            <TableRow>\n              <TableHead>Equipment Name & Category</TableHead>\n              <TableHead>Status</TableHead>\n              <TableHead>Assigned To</TableHead>\n              <TableHead>Serial Number</TableHead>\n              <TableHead>Last Check Out</TableHead>\n              <TableHead>Actions</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {data.map((item) => (\n              <TableRow key={item.id}>\n                <TableCell>{item.name} ({item.category})</TableCell>\n                <TableCell>\n                  <StatusBadge status={item.status} />\n                </TableCell>\n                <TableCell>\n                  <UserAvatar user={item.assignedTo} />\n                </TableCell>\n                <TableCell>{item.serialNumber}</TableCell>\n                <TableCell>{formatDate(item.lastCheckOut)}</TableCell>\n                <TableCell>\n                  <div className=\"flex space-x-2\">\n                    <Button size=\"sm\" variant=\"ghost\" asChild>\n                      <Link to={`/equipment/${item.id}`} aria-label={`View details for ${item.name}`}>\n                        View\n                      </Link>\n                    </Button>\n                    <Button size=\"sm\" variant=\"ghost\" asChild>\n                      <Link to={`/equipment/${item.id}/edit`} aria-label={`Edit ${item.name}`}>\n                        Edit\n                      </Link>\n                    </Button>\n                  </div>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "Test responsive behavior across different viewport sizes. Use accessibility testing tools like axe to identify and fix accessibility issues. Test keyboard navigation to ensure all interactive elements are accessible without a mouse. Test with screen readers to verify proper ARIA attributes and focus management. Create Storybook stories that demonstrate responsive behavior.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Responsive Layouts and Mobile Views",
            "description": "Create responsive layouts for all pages and components, with special attention to mobile-specific views like card layouts for equipment lists.",
            "dependencies": [],
            "details": "1. Use CSS Grid and Flexbox for fluid layouts\n2. Implement mobile-first approach with media queries\n3. Create card view components for equipment lists on mobile\n4. Test breakpoints at 320px, 768px, 1024px, and 1440px\n5. Implement responsive navigation (hamburger menu for mobile)\n6. Ensure forms adapt to different screen sizes\n7. Use relative units (rem, em, %) instead of fixed pixels\n8. Optimize touch targets for mobile (min 44x44px)",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Keyboard Navigation and Focus Management",
            "description": "Ensure all interactive elements are accessible via keyboard and implement proper focus management for modals and dynamic content.",
            "dependencies": [
              1
            ],
            "details": "1. Add visible focus indicators for all interactive elements\n2. Implement keyboard shortcuts for common actions\n3. Create focus traps for modals and dialogs\n4. Add skip links at the top of pages\n5. Ensure logical tab order matches visual layout\n6. Implement arrow key navigation for complex components\n7. Add focus restoration when dialogs close\n8. Test all workflows using keyboard-only navigation",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement ARIA Attributes and Screen Reader Support",
            "description": "Add appropriate ARIA roles, states, and properties to ensure screen reader compatibility across all components.",
            "dependencies": [
              2
            ],
            "details": "1. Add aria-label and aria-labelledby where appropriate\n2. Implement aria-live regions for dynamic content updates\n3. Use aria-expanded for collapsible sections\n4. Add aria-controls to connect controls with their targets\n5. Implement aria-selected for tabs and similar components\n6. Use appropriate semantic HTML elements (nav, main, section)\n7. Add aria-describedby for form fields with additional instructions\n8. Ensure all icons and visual indicators have text alternatives",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Conduct Accessibility Testing and Remediation",
            "description": "Test the application with various assistive technologies and fix any accessibility issues to meet WCAG 2.1 AA standards.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Run automated tests using axe-core or similar tools\n2. Test with screen readers (NVDA, JAWS, VoiceOver)\n3. Verify color contrast meets WCAG AA standards (4.5:1 for normal text)\n4. Test with keyboard-only navigation\n5. Verify content is accessible at 200% zoom\n6. Test with different browser/screen reader combinations\n7. Create an accessibility statement documenting conformance\n8. Fix identified issues and document any known limitations",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-16T21:49:39.308Z",
      "updated": "2025-07-16T22:03:20.660Z",
      "description": "Tasks for master context"
    }
  }
}